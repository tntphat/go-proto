// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.6.1
// source: onchain.proto

package protobufpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// OnchainSrvClient is the client API for OnchainSrv service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OnchainSrvClient interface {
	MintNFT(ctx context.Context, in *MintNFTReq, opts ...grpc.CallOption) (*MintNFTRes, error)
	Cancel(ctx context.Context, in *CancelReq, opts ...grpc.CallOption) (*CancelRes, error)
	Buy(ctx context.Context, in *BuyReq, opts ...grpc.CallOption) (*BuyRes, error)
}

type onchainSrvClient struct {
	cc grpc.ClientConnInterface
}

func NewOnchainSrvClient(cc grpc.ClientConnInterface) OnchainSrvClient {
	return &onchainSrvClient{cc}
}

func (c *onchainSrvClient) MintNFT(ctx context.Context, in *MintNFTReq, opts ...grpc.CallOption) (*MintNFTRes, error) {
	out := new(MintNFTRes)
	err := c.cc.Invoke(ctx, "/protobuf.OnchainSrv/MintNFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *onchainSrvClient) Cancel(ctx context.Context, in *CancelReq, opts ...grpc.CallOption) (*CancelRes, error) {
	out := new(CancelRes)
	err := c.cc.Invoke(ctx, "/protobuf.OnchainSrv/Cancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *onchainSrvClient) Buy(ctx context.Context, in *BuyReq, opts ...grpc.CallOption) (*BuyRes, error) {
	out := new(BuyRes)
	err := c.cc.Invoke(ctx, "/protobuf.OnchainSrv/Buy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OnchainSrvServer is the server API for OnchainSrv service.
// All implementations must embed UnimplementedOnchainSrvServer
// for forward compatibility
type OnchainSrvServer interface {
	MintNFT(context.Context, *MintNFTReq) (*MintNFTRes, error)
	Cancel(context.Context, *CancelReq) (*CancelRes, error)
	Buy(context.Context, *BuyReq) (*BuyRes, error)
	mustEmbedUnimplementedOnchainSrvServer()
}

// UnimplementedOnchainSrvServer must be embedded to have forward compatible implementations.
type UnimplementedOnchainSrvServer struct {
}

func (UnimplementedOnchainSrvServer) MintNFT(context.Context, *MintNFTReq) (*MintNFTRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintNFT not implemented")
}
func (UnimplementedOnchainSrvServer) Cancel(context.Context, *CancelReq) (*CancelRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (UnimplementedOnchainSrvServer) Buy(context.Context, *BuyReq) (*BuyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Buy not implemented")
}
func (UnimplementedOnchainSrvServer) mustEmbedUnimplementedOnchainSrvServer() {}

// UnsafeOnchainSrvServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OnchainSrvServer will
// result in compilation errors.
type UnsafeOnchainSrvServer interface {
	mustEmbedUnimplementedOnchainSrvServer()
}

func RegisterOnchainSrvServer(s grpc.ServiceRegistrar, srv OnchainSrvServer) {
	s.RegisterService(&OnchainSrv_ServiceDesc, srv)
}

func _OnchainSrv_MintNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MintNFTReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnchainSrvServer).MintNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.OnchainSrv/MintNFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnchainSrvServer).MintNFT(ctx, req.(*MintNFTReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _OnchainSrv_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnchainSrvServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.OnchainSrv/Cancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnchainSrvServer).Cancel(ctx, req.(*CancelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _OnchainSrv_Buy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnchainSrvServer).Buy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.OnchainSrv/Buy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnchainSrvServer).Buy(ctx, req.(*BuyReq))
	}
	return interceptor(ctx, in, info, handler)
}

// OnchainSrv_ServiceDesc is the grpc.ServiceDesc for OnchainSrv service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OnchainSrv_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protobuf.OnchainSrv",
	HandlerType: (*OnchainSrvServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MintNFT",
			Handler:    _OnchainSrv_MintNFT_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _OnchainSrv_Cancel_Handler,
		},
		{
			MethodName: "Buy",
			Handler:    _OnchainSrv_Buy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "onchain.proto",
}
